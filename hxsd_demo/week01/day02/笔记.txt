javascript预编译

JavaScript的“编译”只是检查有没有代码错误，不会运行代码

1、先预定义变量，再预定义函数，在这个阶段，当前作用域中的变量和函数，将被提升到作用域的顶部

2、变量的预编译只作声明，并未赋值

3、function语句定义的函数，不仅声明了函数名，而且函数体也进行了处理

4、匿名函数不会预编译


常见错误：

Uncaught SyntaxError:未知的语法错误

Uncaught TypeError: 未知的类型错误

Uncaught RangeError:未知的范围（无限死循环）

Unexpected token：意外的符合


---------------------------------------------------------------------------
变量的作用域

在函数中使用var关键字进行显式申明的变量是做为局部变量，而没有用var关键字，使用直接赋值方式声明的是全局变量。

变量作用域以函数为界限（条件判断语句中声明的变量没有单独的作用域概念）

---------------------------------------------------------------------------

输出

document.write是重写整个document, 写入内容是字符串的html

innerHTML是HTMLElement的属性，是一个元素的内部html内容
innerHTML很多情况下都优于document.write，其原因在于其允许更精确的控制要刷新页面的那一个部分
------------------------------------------------------------------------

加法运算

"abc"+"def"   结果：abcdef 字符串+字符串=字符串相连

123+123       结果：246  数字+数字=数学计算

"abc"+123     结果：abc123  字符串+数字=符串连接数数字

-------------------------------------------------------------------------
数组

在单独的变量名中存储一系列的值

var arr=[123,454,45,34,656,34324,343]

数组的索引(下标):从0开始，对应每一个数组中的值

数组的长度：arr.length

数组的赋值：arr[索引]=值

清空数组：arr=[ ]或者 arr.length=0;

-----------------------------------------------------------------------------
获取对象集合
getElementsByTagName（标签名）  getElementsByClassName（className）  getElementsByName（name）

注意：是对象集合而不是单个对象，可以通过索引找到单个对象

例:
var aLi=document.getElementsByTagName('li');   //aLi是一个对象集合
aLi[0].onclick=function(){……}  //操作第一个li

相类似的还有 

-----------------------------------------------------------------------------

var i=0; //iterator  [计] 迭代器，迭代程序;  index指数; 指示; 标志; 索引


//while  先判断，后运行---------------
while(i<10){
	console.log(i);
	i++;
};


//do while  先运行，后判断---------------------
do{
	console.log(i);	
	i++;
}
while(i<10);



//for(初始，范围 ，增量) -----------------------------------
for(i=0;i<10;i++){
	console.log(i);
};

alert(i);

